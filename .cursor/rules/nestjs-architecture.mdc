---
description: 
globs: 
alwaysApply: true
---
# NestJS Backend Architecture Rules - Based on TeaCoder Repository Analysis

## Project Structure & Organization Rules

### Root Level Files

- Keep configuration files (package.json, tsconfig.json, nest-cli.json) at root level
- Include Docker setup (Dockerfile, docker-compose.yml, .dockerignore) for containerization
- Place database schema and migrations in prisma/ directory
- Use test/ directory for e2e tests only
- All application code must be within src/ directory

### Source Directory Structure

src/
├── main.ts # Application entry point - configure app, validation, CORS
├── app.module.ts # Root module - import all feature modules
├── api/ # API layer - controllers, services, DTOs
├── common/ # Shared utilities and reusable components
├── config/ # Configuration modules and environment handling
├── infra/ # Infrastructure components (database, redis, etc.)
├── libs/ # External service integrations and wrappers
└── prisma/ # Database service layer and Prisma client

## Feature Module Architecture

### Module Organization

- Each business domain gets its own module directory under src/api/
- Use feature-based organization, not technical layer organization
- Standard structure per feature:
  ```
  feature-name/
  ├── feature-name.controller.ts    # HTTP endpoints and request handling
  ├── feature-name.module.ts        # Module definition and dependency injection
  ├── feature-name.service.ts       # Business logic and data operations
  └── dto/                          # Data Transfer Objects
      ├── index.ts                  # Export all DTOs for clean imports
      ├── create-feature.dto.ts     # Creation request validation
      ├── update-feature.dto.ts     # Update request validation
      └── feature.dto.ts            # Response formatting
  ```

### Controller Rules

- Controllers should only handle HTTP concerns (routing, validation, response formatting)
- No business logic in controllers - delegate to services
- Use proper HTTP status codes and response structures
- Apply guards and decorators for authentication/authorization
- Validate all incoming data using DTOs

### Service Rules

- Services contain all business logic
- Services should be stateless and injectable
- Use dependency injection for database and external service access
- Implement proper error handling and logging
- Keep services focused on single responsibility

### DTO Rules

- Create separate DTOs for create, update, and response operations
- Use class-validator decorators for validation
- Always include index.ts for clean exports
- DTOs should only contain data structure, no logic
- Use proper TypeScript typing

## Authentication & Authorization Architecture

### Auth Module Structure

```
auth/
├── account/          # User account management (registration, profile)
├── external/         # OAuth/external auth providers (Google, GitHub)
├── mfa/             # Multi-factor authentication (TOTP, passkeys)
└── session/         # Session management and validation
```

### Security Implementation Rules

- Use guards for all protected endpoints
- Implement session-based authentication with Redis storage
- Support multiple authentication methods (password, OAuth, MFA)
- Create reusable decorators (@Auth, @Roles, @Authorized)
- Validate sessions on every protected request

## Common Utilities Architecture

### Required Common Components

```
common/
├── decorators/       # Custom NestJS decorators (@Auth, @Roles, etc.)
├── guards/          # Authentication & authorization guards
├── interceptors/    # Request/response processing (logging, formatting)
├── interfaces/      # TypeScript interfaces and type definitions
└── utils/           # Pure utility functions (validation, formatting)
```

### Decorator Rules

- Create @Auth() decorator for simple authentication
- Create @Roles() decorator for role-based access control
- Create HTTP method decorators for consistent API documentation
- Use @Authorized() for fine-grained permission control

### Guard Rules

- SessionGuard for validating user sessions
- RolesGuard for role-based access control
- ProviderGuard for OAuth provider validation
- Guards should be reusable across controllers

### Interceptor Rules

- LoggingInterceptor for request/response logging
- Interceptors should not modify business logic
- Use for cross-cutting concerns only

## Infrastructure Layer Rules

### Database Layer (infra/prisma/)

- Use Prisma as the database ORM
- Create PrismaService as global injectable service
- Abstract database operations through service layer
- Use transactions for complex operations
- Implement proper error handling for database operations

### Redis Layer (infra/redis/)

- Use Redis for session storage and caching
- Create RedisService for connection management
- Implement proper connection pooling
- Use Redis for rate limiting and temporary data

### Module Rules

- Make infrastructure modules global when needed
- Use proper dependency injection
- Implement health checks for external dependencies

## External Service Integration (libs/)

### Service Integration Structure

```
libs/
├── libs.module.ts           # Central module for all external services
├── mail/                    # Email service with template support
│   ├── mail.service.ts     # Email sending logic
│   ├── mail.processor.ts   # Queue processing for async emails
│   └── templates/          # React email templates
├── storage/                 # File storage service
└── kinescope/              # Video service integration (example)
```

### Email Service Rules

- Use React components for email templates
- Implement queue processing for async email sending
- Support multiple template types (verification, reset, notifications)
- Use proper error handling and retry logic

### Storage Service Rules

- Abstract file storage operations
- Support multiple storage providers
- Implement proper file validation
- Use proper error handling for file operations

## Configuration Management

### Configuration File Organization

- Separate configuration file for each major service
- Examples: cors.config.ts, swagger.config.ts, mailer.config.ts
- Use environment-based configuration (dev/prod)
- Validate configuration at startup

### Configuration Rules

- Use ConfigService for environment variable access
- Export typed configuration objects
- Validate required environment variables
- Use default values where appropriate

## Data Validation & DTOs

### DTO Design Patterns

- CreateDTO: For resource creation with required fields
- UpdateDTO: For resource modification with optional fields
- ResponseDTO: For API response formatting and data exposure
- QueryDTO: For request parameter validation and filtering

### Validation Rules

- Use class-validator decorators on all DTOs
- Validate all incoming request data
- Sanitize data before processing
- Return consistent error messages for validation failures

## Error Handling & Logging

### Error Handling Rules

- Use NestJS built-in exception filters
- Create custom exceptions for business logic errors
- Log all errors with proper context
- Return consistent error response format
- Never expose internal system details in error messages

### Logging Rules

- Use structured logging with proper log levels
- Log all incoming requests and responses
- Log business logic operations
- Include correlation IDs for request tracking
- Use different log levels (error, warn, info, debug)

## Testing Standards

### Test Organization

- E2E tests in test/ directory
- Unit tests alongside source files (optional)
- Integration tests for database operations
- Mock external services in tests

### Testing Rules

- Test critical business logic paths
- Test authentication and authorization flows
- Test error handling scenarios
- Use proper test data setup and cleanup

## Code Quality & Standards

### TypeScript Rules

- Use strict TypeScript configuration
- Define interfaces for all data structures
- Use proper typing, avoid 'any' type
- Export types from dedicated files

### Code Style Rules

- Use ESLint and Prettier for code formatting
- Follow consistent naming conventions
- Use descriptive variable and function names
- Keep functions and classes focused and small

### Import Rules

- Use absolute imports with path mapping
- Group imports: external libraries, internal modules, relative imports
- Use index.ts files for clean exports
- Avoid circular dependencies

## API Design Standards

### REST API Rules

- Use proper HTTP methods (GET, POST, PUT, DELETE, PATCH)
- Use consistent URL patterns (/api/resource/:id)
- Return proper HTTP status codes
- Use consistent response structure

### Documentation Rules

- Use Swagger/OpenAPI for API documentation
- Document all endpoints with examples
- Include authentication requirements
- Document error responses

## Security Best Practices

### Authentication Rules

- Use session-based authentication
- Implement proper session expiration
- Support multiple authentication methods
- Validate all authentication tokens

### Authorization Rules

- Implement role-based access control
- Use guards for endpoint protection
- Validate permissions at service level
- Log all authorization decisions

### Data Security Rules

- Validate all input data
- Sanitize data before database operations
- Use parameterized queries (Prisma handles this)
- Hash sensitive data (passwords, tokens)

## Performance & Optimization

### Database Rules

- Use database indexes for frequently queried fields
- Implement proper pagination for list endpoints
- Use database transactions for data consistency
- Monitor and optimize slow queries

### Caching Rules

- Use Redis for session and temporary data storage
- Implement caching for frequently accessed data
- Use proper cache invalidation strategies
- Monitor cache hit rates

### API Performance Rules

- Implement rate limiting for API endpoints
- Use proper HTTP caching headers
- Optimize response payload size
- Monitor API response times

## Deployment & DevOps

### Docker Rules

- Use multi-stage Docker builds
- Minimize Docker image size
- Use proper environment variable handling
- Implement health checks in containers

### Environment Rules

- Use environment variables for configuration
- Never commit secrets to version control
- Use different configurations for dev/staging/prod
- Validate environment configuration at startup

## Implementation Guidelines

When implementing any feature:

1. Follow the established directory structure
2. Create proper DTOs for data validation
3. Implement authentication/authorization as needed
4. Add proper error handling and logging
5. Write tests for critical functionality
6. Document API endpoints
7. Follow TypeScript best practices
8. Use dependency injection properly

## Naming Conventions

### File Naming

- Controllers: `feature-name.controller.ts`
- Services: `feature-name.service.ts`
- Modules: `feature-name.module.ts`
- DTOs: `create-feature.dto.ts`, `update-feature.dto.ts`, `feature.dto.ts`
- Guards: `feature-name.guard.ts`
- Decorators: `feature-name.decorator.ts`

### Class Naming

- Controllers: `FeatureNameController`
- Services: `FeatureNameService`
- Modules: `FeatureNameModule`
- DTOs: `CreateFeatureDto`, `UpdateFeatureDto`, `FeatureDto`
- Guards: `FeatureNameGuard`

### Method Naming

- Use descriptive verbs: `createUser`, `updateUserProfile`, `deleteUserById`
- Controller methods should match HTTP operations
- Service methods should reflect business operations
- Use async/await for all asynchronous operations

